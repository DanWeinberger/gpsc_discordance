---
title: "discordance"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(reshape2)
library(ggplot2)
library(dplyr)
library(phylogram)
library(dendextend)
library(pbapply)
library(stringr)
library(plotly)
library(flextable)
```

Download all files from microreact. Not all the GPSC seem to have a microreact project associated. the subset below all had files.

```{r}
gpcs.test<-c(1:27,30:34, 37:41, 43, 47:48, 50:58, 61:62,67:68,70,72, 76,78, 79,80,81,90,91,93, 94,97,103,105,117, 131)
```

```{r, eval=F}
library(httr)
library(phylogram)
library(dendextend)

for(i in gpcs.test){
path <- paste0("https://microreact.org/api/viewer/tree?project=gpsGPSC",i)
path2<-paste0("https://microreact.org/api/viewer/data?project=gpsGPSC",i)
download.file(path2, destfile=paste0("./metadata/data_gpcs",i,".csv"))
download.file(path, destfile=paste0("./trees/tree_gpcs",i,".nwk"))
}
```


### Read in all trees and save in a list
```{r}
trees <- vector("list",length(gpcs.test))
trees.to.cut <- vector("list",length(gpcs.test))

for(i in 1:length(gpcs.test)){
  trees[[i]]<-ape::read.tree(paste0("microreact/tree_gpcs",gpcs.test[i],".nwk"))
  trees.to.cut[[i]]<-read.dendrogram(paste0("microreact/tree_gpcs",gpcs.test[i],".nwk"))

}  
```

### Import the metadata

```{r}
###Import the metadata
metads <- vector("list",length(gpcs.test))
for(i in 1:length(gpcs.test)){
  metads[[i]]<-read.csv(paste0("microreact/data_gpcs",gpcs.test[i],".csv"))
} 
```

## classify the samples based on a cutpoint
```{r}
tree.cutter<-function(tree.list, cutpoint){
  test1<-as_hclust_fixed(tree.list)
  test2<-cutree(test1, h=cutpoint)
  test3<-as.data.frame(test2)
  names(test3)<-'tree.grp'
  test3$ID<-row.names(test3)
  return(test3)
}

tree.grps200<-lapply(trees.to.cut,tree.cutter,cutpoint=100)

```

## Merge in with meta data
```{r}
metads<-lapply(metads, function(x){
  x$ID<-as.character(x$ID)
  return(x)
 })

meta.merge<-function(tree.ds, meta.ds){
  test1<-merge(tree.ds, meta.ds, by='ID')
  test1$phylo.grp<-paste(test1$GPSC, test1$tree.grp, sep='_')
  test1$In_Silico_Serotype<-as.character(test1$In_Silico_Serotype)
  test1<-test1[,c('ID', 'In_Silico_Serotype','phylo.grp','In_Silico_Serotype' )]
  return(test1)
}

grp.assign200<-mapply(meta.merge,tree.ds=tree.grps200, meta.ds=metads , SIMPLIFY=F)
#phylo.grps200<- do.call('rbind.data.frame',grp.assign200)
```


Distance matrix
Generate a distance matrix based on the phylogenetic tree. Then identify the closest neighbors of switched variants on same part of the tree (based on the tree.cut)

```{r, eval=F}
distance_mat_fun <- function(tree.ds, meta.ds){
  
  # for(i in 1:length(trees)){
  #   
  # tree.ds=trees[[i]]
  # meta.ds=grp.assign200[[i]]
  # print(i)
  
  dist.t1 <- cophenetic.phylo(tree.ds)
  dist.t1.m <- reshape2::melt(dist.t1)
  
  dist.t1.m <- merge(dist.t1.m, meta.ds[,c('ID','In_Silico_Serotype',"phylo.grp")], by.x='Var1', by.y='ID', all.x=T)
  dist.t1.m <- merge(dist.t1.m, meta.ds[,c('ID','In_Silico_Serotype',"phylo.grp")], by.x='Var2', by.y='ID', all.x=T)
  names(dist.t1.m) <- c('ID2','ID1','distance','sero1','phylo_grp1', 'sero2','phylo_grp2')
  
  dist.t1.m <- dist.t1.m[dist.t1.m$phylo_grp1 == dist.t1.m$phylo_grp2 , ] #only consider pairs on same part of the tree
  
  dist.t1.m$change_st <- 1*(dist.t1.m$sero1!=dist.t1.m$sero2)
  
  dist.t1.m <- dist.t1.m[dist.t1.m$distance>0,] #remove diagonal from the distance matrix
  
 # hist(dist.t1.m$distance)
  
  
  #dist2 <- dist.t1.m[dist.t1.m$distance<200,] #restrict to more closely-related strains
  
  # ave_dist <- dist2 %>%
  #   group_by(change_st) %>%
  #   summarize(ave_dist=mean(distance))
  
  dist.t1.m$change_st[is.na(dist.t1.m$change_st)] <- -1 #fixes issue with NAs
  
  if(sum(dist.t1.m$change_st)>0){
  closest_match <- dist.t1.m %>%
    filter(change_st==1) %>%
    arrange(sero1, sero2,distance, .by_group = TRUE) %>%
    group_by(sero1, sero2) %>%
      mutate(distance_rank = 1:n()) %>%
    filter(distance_rank==1 & distance <0.01)
  
    return(closest_match)

  }else{
    return(NULL)
  }
}



all_switches.ls <- pbmapply(FUN=distance_mat_fun, tree.ds=trees,meta.ds=grp.assign200, SIMPLIFY = F)

all_switches <- bind_rows(all_switches.ls)

write.csv(all_switches, './results/all_switches.csv' )
```

```{r}
all_switches <- read.csv( './results/all_switches.csv' )

```


Read in presence/absence
#Source: https://figshare.com/projects/Gladstone_et_al_MGEN_2019/69173
#freq of cloud genes, etc https://figshare.com/articles/dataset/Roary_count_of_core_and_accessory_genes_of_the_whole_collection/11357828



=======
Read in presence/absence
#Source: https://figshare.com/projects/Gladstone_et_al_MGEN_2019/69173
#freq of cloud genes, etc https://figshare.com/articles/dataset/Roary_count_of_core_and_accessory_genes_of_the_whole_collection/11357828
```{r}

# a1 <- read.csv('./Data/gene_presence_absence_minimised.csv')
# saveRDS(a1,'./Data/gene_presence_absence_minimised.rds')

a1 <- readRDS('./Data/gene_presence_absence_minimised.rds') #this dataset has ALL COGS, not jus int freq


#Identify and deduplicate StA=1, STB=2 vs StA=2 STB=1 
all_switches2 <- all_switches %>%
  mutate(ID1 =  gsub('#','.',ID1), ID2 = gsub('#','.',ID2) )

uniqueIds <- apply(all_switches2,1, function(x){
  unique_id = paste(sort(c(x['ID1'], x['ID2'])), collapse='_')
  return(unique_id)
})

all_switches2 <- cbind.data.frame(all_switches2,'uniqueIds'=uniqueIds)

all_switches2 <- all_switches2 %>%
  group_by(uniqueIds) %>%
  mutate(pair_rep=row_number()) %>%
    ungroup() %>%
 filter(pair_rep==1) 

gene_freqN <- apply(a1[, -c(1:15)],1, sum, na.rm=T) #These are the very common or very rare genes, NOT the intermediate freq

all_switches2 <- all_switches2
all_switches2$ID2 <- gsub('#','.',all_switches2$ID2)
all_switches2$ID1 <- gsub('#','.',all_switches2$ID1)


gene_freq <- apply(a1[, -c(1:15)],1, sum, na.rm=T)/ (ncol(a1)-15) #These are the very common or very rare genes, NOT the intermediate freq

#Compare pairs of strains

compare.fun <- function(switchN){
  
  col.strain1 <- grep( paste0(all_switches2$ID1[switchN],'.velvet'),colnames(a1))
  
  col.strain2 <- grep( paste0(all_switches2$ID2[switchN],'.velvet'),colnames(a1))


  regexp <- "[[:digit:]]+"

  sg1 <- str_extract(all_switches2$sero1[switchN], regexp)
  sg2 <- str_extract(all_switches2$sero2[switchN], regexp)  
  
  b1 <- a1[, c(1:3,col.strain1, col.strain2 )]
  names(b1) <- c('Gene','Non.unique.Gene.name', 'Annotation', 'Gene_Pres_A', 'Gene_Pres_B')
  b1[,4][is.na(b1[,4])] <-   0
  b1[,5][is.na(b1[,5])] <-   0
  
  b1$stA =all_switches2$sero1[switchN]
  b1$stB =all_switches2$sero2[switchN]
  
  b1$idA =colnames(a1)[col.strain1]
  b1$idB =colnames(a1)[col.strain2]

  if(length(which(b1[,4] != b1[,5])) > 0){

    c1 <- b1[b1[,4] != b1[,5] & !is.na(b1[,4]), ]
    c1$change_serogrp <- 1*(sg1 != sg2 )
  }else{
    c1 <- NULL
  }
  return(c1)
}

unique.genes.ls <- lapply(1:nrow(all_switches2), compare.fun)
unique.genes <- bind_rows(unique.genes.ls)

#sort(table(unique.genes$Annotation), decreasing=T)

cog_freq <- unique.genes %>%
    group_by(Gene, Annotation,change_serogrp) %>%
    summarise('cog_freq'=n()) %>%
    arrange(desc(cog_freq)) %>%
    mutate(change_serogrp= paste0('sg_change_', change_serogrp))

cog_freq.c <- reshape2::dcast(cog_freq, Gene+Annotation ~ change_serogrp) %>%
  filter(sg_change_1 + sg_change_0 >=20) %>%
  mutate(ratio= sg_change_1/sg_change_0)


```
Interesting ones:
group_11429 spermidine synthase found in 53 SG changes, 1 non SG change; This is part of polyamine biosynthesis, which has been linked to CPS expression https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5872165/
for other related compounds " Characterization of Î”speA indicates reduced galactose to glucose interconversion via the Leloir pathway. This in turn will limit the availability of UDP-galactose, a precursor of serotype 4 CPS, and UDP-N-acetylglucosamine (UDP-GlcNAc), a nucleotide sugar precursor that is at the intersection of CPS and peptidoglycan repeat unit biosynthesis" https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7990898/

** check if GlcNAC or Gal are more common with Spermidine genes

group_16274 family 2 glycosyl transferase

maybe: thioredoxin (different alleles, some associated with cps switch)

#### less interesting (does nto show up on other analysis below) 

uracil-DNA glycosylase ung


group_15047 VncR response regulator  the response regulator of the vancomycin resistance locus; regulates CPS production: https://www.frontiersin.org/articles/10.3389/fmicb.2019.02279/full; influences response to serum exposure--this is a common gene; but we are detecting a specific allele.

glyA serine hydroxymethyltransferase--this is a common gene; but we are detecting a specific allele present at ~30%.

group_11218 serine hydroxymethyltransferase

kpsT_1 ABC transporter ATP-binding protein (ON the CPS locus) https://academic.oup.com/femsle/article/149/1/1/529951


cbiO_1 putative histone acetyltransferase/ cobalt transporter  --evaluated in Jason's paper: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8208518/
	cbi0-cobalt ABC transporter ATP-binding protein

comA, comB: competence factor transporting ATP-binding protein/permease ComA


16S ribosomal RNA methyltransferase RsmE: involved in tet resistance (https://journals.asm.org/doi/10.1128/mBio.01344-20)

acetyltransferase GNAT family ; essential for virulence in lung: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2788772/


## How to do this analysis correctly
- Need to have all pairwise relationships within clade, including those that switch and those that didn't
- then have a 0/1 for discordance at each location
--or more simply, calculate proportion of isolates with the COG and proportion of SG switches ith the COG


```{r}


overall_cog_freq <- cbind.data.frame('Gene'=a1$Gene , 'Annotation'=a1$Annotation, gene_freq,gene_freqN)

cog_freq.c2 <- merge(cog_freq.c,overall_cog_freq , by=c('Gene','Annotation')) %>%
  mutate(gene_freq_switch= sg_change_0 + sg_change_1, 
         gene_freq_noswitch = gene_freqN -gene_freq_switch ,
         gene_prop_noswitch = gene_freq_noswitch/13453, 
         gene_prop_switch = gene_freq_switch/264 ,
         ratio_any_switch= gene_prop_switch/gene_prop_noswitch  ) %>%
        filter(ratio_any_switch>0 & ratio_any_switch<1000) %>%
  arrange(-ratio_any_switch)

View(cog_freq.c2)

plot(log(cog_freq.c2$ratio_any_switch), cog_freq.c2$gene_freq)

p1 <- ggplot(cog_freq.c2 , aes(x=gene_freq, y=sg_change_1, text=Annotation))+ 
       geom_point()+
       theme_classic()
ggplotly(p1)
```

Thioredoxin https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3914529/ group_9046, group_9050

	
group_9246,group_9247 glycerophosphoryl diester phosphodiesterase "codes for a plasma membrane glycerophosphoryl diester phosphodiesterase (EC 3.1.4.46), an enzyme of the glycerophospholipid metabolism pathway involved in the production of glycerol-3-phosphate along with choline or ethanolamine from glycerophosphocholine or glycerophosphoethanolamine, respectively "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4652380/"

Spermidine synthase group11429

```{r}
glyc <- a1 %>% filter(Gene=='group_11429') %>%
  select(starts_with("X")) %>%
  t() %>%
  as.data.frame() 

glyc$ID <- row.names(glyc) 

glyc <- glyc %>%
  mutate(ID= gsub('X','',ID),
         ID= gsub('.velvet','',ID),
         ID= gsub('_','.',ID),
         V1= if_else(is.na(V1), 0, 1))

metads.st <- lapply(metads, function(x)
                    x %>%
                      select(ID, ERR,In_Silico_Serotype ) %>%
                      mutate(In_Silico_Serotype=as.character(In_Silico_Serotype))%>%
                      rename(st=In_Silico_Serotype)
                    ) %>%
                     bind_rows()%>%
                    mutate(ID =gsub('#','.',ID), ID =gsub('_','.',ID) )
glyc2 <- merge(glyc,metads.st, by='ID', all=T )


t1 <- glyc2 %>%
  group_by(st) %>%
  summarize( N=n(), glyc2_present=sum(V1)) %>%
  mutate( percent_with_glyc2 = glyc2_present/N ) %>%
  arrange(-percent_with_glyc2)

ps_comp <- read.csv('https://raw.githubusercontent.com/weinbergerlab/sero_switch_paper/master/Data/ps_composition.csv')

t1 <- merge(t1, ps_comp, by.x='st', by.y='Serotype')

flextable(t1)
write.csv(t1,'./results/sperm_presence.csv')
  
```

pull out spermidine  discordant pairs
```{r}
glyc3 <- unique.genes %>%
  filter(Gene=='group_11429') %>%
  select(Gene,stA, Gene_Pres_A,stB,Gene_Pres_B)

glyc3 <- merge(glyc3, ps_comp, by.x='stA', by.y='Serotype')
glyc3 <- merge(glyc3, ps_comp, by.x='stB', by.y='Serotype')

View(glyc3)

write.csv(glyc3,'./results/sperm_pairings.csv')


```

