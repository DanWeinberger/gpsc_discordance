---
title: "discordance"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(reshape2)
library(ggplot2)
library(dplyr)
library(phylogram)
library(dendextend)
library(pbapply)
library(stringr)
library(plotly)
library(flextable)
```

Download all files from microreact. Not all the GPSC seem to have a microreact project associated. the subset below all had files.

```{r}
gpcs.test<-c(1:27,30:34, 37:41, 43, 47:48, 50:58, 61:62,67:68,70,72, 76,78, 79,80,81,90,91,93, 94,97,103,105,117, 131)
```

```{r, eval=F}
library(httr)
library(phylogram)
library(dendextend)

for(i in gpcs.test){
path <- paste0("https://microreact.org/api/viewer/tree?project=gpsGPSC",i)
path2<-paste0("https://microreact.org/api/viewer/data?project=gpsGPSC",i)
download.file(path2, destfile=paste0("./metadata/data_gpcs",i,".csv"))
download.file(path, destfile=paste0("./trees/tree_gpcs",i,".nwk"))
}
```


### Read in all trees and save in a list
```{r}
trees <- vector("list",length(gpcs.test))
trees.to.cut <- vector("list",length(gpcs.test))

for(i in 1:length(gpcs.test)){
  trees[[i]]<-ape::read.tree(paste0("microreact/tree_gpcs",gpcs.test[i],".nwk"))
  trees.to.cut[[i]]<-read.dendrogram(paste0("microreact/tree_gpcs",gpcs.test[i],".nwk"))

}  


for(i in 1:length(trees)){
  print(i)
print( grep("9789_3#60", trees$tip.label))
}
```

### Import the metadata

```{r}
metads <- vector("list",length(gpcs.test))

for(i in 1:length(gpcs.test)){
  metads[[i]]<-read.csv(paste0("microreact/data_gpcs",gpcs.test[i],".csv")) %>%
      select(ID, In_Silico_Serotype,GPSC) %>%
    rename(phylo.grp=GPSC)%>%
     mutate (ID=as.character(ID), In_Silico_Serotype= as.character(In_Silico_Serotype))
} 

metads.df <- bind_rows(metads)
```

## classify the samples based on a cutpoint
```{r}
# tree.cutter<-function(tree.list, cutpoint){
#   test1<-as_hclust_fixed(tree.list)
#   test2<-cutree(test1, h=cutpoint)
#   test3<-as.data.frame(test2)
#   names(test3)<-'tree.grp'
#   test3$ID<-row.names(test3)
#   return(test3)
# }
# 
# tree.grps200<-lapply(trees.to.cut,tree.cutter,cutpoint=100)

```

Distance matrix
Generate a distance matrix based on the phylogenetic tree. Then identify the closest neighbors of switched variants on same part of the tree (based on the tree.cut)

```{r, eval=F}
distance_mat_fun <- function(tree.ds, meta.ds){
  
  # for(i in 1:length(trees)){
  # 
  # tree.ds=trees[[i]]
  # meta.ds=metads[[i]]
  # print(i)
  
  dist.t1 <- cophenetic.phylo(tree.ds)
  dist.t1.m <- reshape2::melt(dist.t1) %>%
    mutate(Var1= gsub("\\'","", Var1),
           Var2= gsub("\\'","", Var2)) %>%
     left_join( meta.ds,  by = c("Var1" = "ID")) %>%
  left_join(  meta.ds, by = c("Var2" = "ID")) %>%
    rename(ID1=Var1, ID2=Var2, distance=value,sero1=In_Silico_Serotype.x, sero2=In_Silico_Serotype.y,
         phylo_grp1=phylo.grp.x, phylo_grp2=phylo.grp.y  ) %>%
          mutate( change_st = if_else(sero1 != sero2,1,0))%>%
              filter(distance>0 )  #keep if change ST, remove diagonal

  closest_match_no_switch <- dist.t1.m %>%
    filter(sero1 == sero2) %>%
    arrange(ID1, sero1, sero2,distance, .by_group = TRUE) %>%
    group_by(ID1, sero1) %>%
      mutate(distance_rank = 1:n(), sero1=as.character(sero1), sero2=as.character(sero2)) %>%
    filter(distance_rank==1 )
     
  if( sum(dist.t1.m$change_st)>0 ){
  closest_match_st_switch <- dist.t1.m %>%
    filter(sero1 != sero2) %>%
    arrange(ID1, sero1, sero2,distance, .by_group = TRUE) %>%
    group_by(ID1, sero1) %>%
      mutate(distance_rank = 1:n(), sero1=as.character(sero1), sero2=as.character(sero2)) %>%
    filter(distance_rank==1 )
  
    closest_match <- bind_rows(closest_match_st_switch,closest_match_no_switch)
  
  }else{
   closest_match <- closest_match_no_switch

  }
    return(closest_match)
 
}


#to check, look at phylo group=30; 28th on the list

all_switches.ls <- pbmapply(FUN=distance_mat_fun, tree.ds=trees,meta.ds=metads, SIMPLIFY = F)

all_switches <- bind_rows(all_switches.ls) #there are more than 13K because some strains show up in column A both for ST switch and non-ST switch

write.csv(all_switches, './results/all_switches.csv' )
```

```{r}
all_switches <- read.csv( './results/all_switches.csv' )

```


Read in presence/absence
#Source: https://figshare.com/projects/Gladstone_et_al_MGEN_2019/69173
#freq of cloud genes, etc https://figshare.com/articles/dataset/Roary_count_of_core_and_accessory_genes_of_the_whole_collection/11357828



## NOTES
For this analysis, consider a within-serogroup switch as same as a pair of same serotype. This contributes to background level of exchange but not likely under metabolic selection due to similarities in CPS
```{r}

# a1 <- read.csv('./Data/gene_presence_absence_minimised.csv')
# saveRDS(a1,'./Data/gene_presence_absence_minimised.rds')

a1 <- readRDS('./Data/gene_presence_absence_minimised.rds') #this dataset has ALL COGS, not jus int freq

 
#Identify and deduplicate StA=1, STB=2 vs StA=2 STB=1 
all_switches2 <- all_switches %>%
  mutate(ID1 =  gsub('#','.',ID1), ID2 = gsub('#','.',ID2) ) %>%
  filter(distance < 1) #THIS FILTER IS VERY IMPORTANT!!! Otherwise compare distant pairs within GPSc

uniqueIds <- apply(all_switches2,1, function(x){
  unique_id = paste(sort(c(x['ID1'], x['ID2'])), collapse='_')
  return(unique_id)
})

all_switches2 <- cbind.data.frame(all_switches2,'uniqueIds'=uniqueIds)

  regexp <- "[[:digit:]]+"

all_switches2 <- all_switches2 %>%
  group_by(uniqueIds) %>%
  mutate(pair_rep=row_number(),
         ID1= gsub("\\'","",ID1),
         ID2= gsub("\\'","",ID2)) %>%
    ungroup() %>%
 filter(pair_rep==1) %>%
  mutate(sg1 = str_extract(sero1, regexp),
         sg2 = str_extract(sero2, regexp),
        sg1= if_else(sero1=='NT', 'NT', sg1),
        sg2= if_else(sero2=='NT', 'NT', sg2),
                 change_serogrp = if_else(sg1!=sg2,1,0)
         )

# gene_freqN <- apply(a1[, -c(1:15)],1, sum, na.rm=T) #These are the very common or very rare genes, NOT the intermediate freq
# 
# gene_freq <- apply(a1[, -c(1:15)],1, sum, na.rm=T)/ (ncol(a1)-15) #These are the very common or very rare genes, NOT the intermediate freq

#Compare pairs of strains

compare.fun <- function(switchN){
  
  
  col.strain1 <- grep( paste0(all_switches2$ID1[switchN],'.velvet'),colnames(a1))
  
  col.strain2 <- grep( paste0(all_switches2$ID2[switchN],'.velvet'),colnames(a1))



  b1 <- a1 %>%
    select(Gene,Non.unique.Gene.name,Annotation, all_of(col.strain1),all_of(col.strain2)) 
   

  b1$stA =all_switches2$sero1[switchN]
  b1$stB =all_switches2$sero2[switchN]
  
  b1$sgA <- all_switches2$sg1[switchN]
  b1$sgB <- all_switches2$sg2[switchN]
  
  b1$idA =colnames(a1)[col.strain1]
  b1$idB =colnames(a1)[col.strain2]
  
  b1$change_serogrp <- 1*(b1$sgA != b1$sgB )


  if(nrow(b1)>0){
      names(b1)[4:5] =  c('Gene_Pres_A', 'Gene_Pres_B')
       b1[,4][is.na(b1[,4])] <-   0
      b1[,5][is.na(b1[,5])] <-   0
    c1 <- b1[b1[,4] != b1[,5] & !is.na(b1[,4]), ]
  }else{
    c1 <- NULL
  }
  
  return(c1)
}

unique.genes.ls <- pblapply(1:nrow(all_switches2), compare.fun)
unique.genes <- bind_rows(unique.genes.ls)

#sort(table(unique.genes$Annotation), decreasing=T)

cog_freq <- unique.genes %>%
  mutate(change_st= if_else(stA!=stB,1,0)) %>%
    group_by(Gene, Annotation, change_serogrp) %>%
    summarise('cog_freq'=n()) %>%
    arrange(desc(cog_freq)) %>%
    mutate(change_serogrp= paste0('sg_change_', change_serogrp))

#this evaluates how often we see discordance in the locus if closest neighbor is a ST switch or not.

cog_freq.c <- reshape2::dcast(cog_freq, Gene+Annotation ~ change_serogrp) %>%
  filter(sg_change_1 + sg_change_0 >=20) %>%
  mutate(ratio= (sg_change_1/sum(all_switches2$change_serogrp==1))/(sg_change_0/sum(all_switches2$change_serogrp==0))) %>%
  arrange(-ratio)

View(cog_freq.c)



```
Interesting ones:

group_11429 spermidine synthase found in 53 SG changes, 1 non SG change; This is part of polyamine biosynthesis, which has been linked to CPS expression https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5872165/
for other related compounds " Characterization of Î”speA indicates reduced galactose to glucose interconversion via the Leloir pathway. This in turn will limit the availability of UDP-galactose, a precursor of serotype 4 CPS, and UDP-N-acetylglucosamine (UDP-GlcNAc), a nucleotide sugar precursor that is at the intersection of CPS and peptidoglycan repeat unit biosynthesis" https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7990898/

also, relatedly: potD_2



group_16274 family 2 glycosyl transferase

maybe: thioredoxin (different alleles, some associated with cps switch)



Thioredoxin https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3914529/ group_9046, group_9050

	
## new analysis leads
lacG 	 6-phospho-beta-galactosidase (also group_9715)
lacE-2
lacT

ald_2 alanine dehydrogenase

murC_1 UDP-N-acetylmuramate--L-alanine ligase

UDP-galactopyranose mutase


```{r}
glyc <- a1 %>% filter(Gene=='lacG') %>%
  select(starts_with("X")) %>%
  t() %>%
  as.data.frame() 

glyc$ID <- row.names(glyc) 

glyc <- glyc %>%
  mutate(ID= gsub('X','',ID),
         ID= gsub('.velvet','',ID),
         ID= gsub('_','.',ID),
         V1= if_else(is.na(V1), 0, 1))

metads.st <- lapply(metads, function(x)
                    x %>%
                      select(ID, In_Silico_Serotype ) %>%
                      mutate(In_Silico_Serotype=as.character(In_Silico_Serotype))%>%
                      rename(st=In_Silico_Serotype)
                    ) %>%
                     bind_rows()%>%
                    mutate(ID =gsub('#','.',ID), ID =gsub('_','.',ID) )

glyc2 <- merge(glyc,metads.st, by='ID', all=T ) %>%
  filter(!is.na(st)) #some isolates found on a1, not found on metadata file


t1 <- glyc2 %>%
  group_by(st) %>%
  summarize( N=n(), glyc2_present=sum(V1)) %>%
  mutate( percent_with_glyc2 = glyc2_present/N ) %>%
  arrange(-percent_with_glyc2)

ps_comp <- read.csv('https://raw.githubusercontent.com/weinbergerlab/sero_switch_paper/master/Data/ps_composition.csv')

t1 <- merge(t1, ps_comp, by.x='st', by.y='Serotype') %>%
    arrange(-percent_with_glyc2)


flextable(t1)
write.csv(t1,'./results/sperm_presence.csv')
  
```

pull out spermidine  discordant pairs
```{r}
glyc3 <- unique.genes %>%
  filter(Gene=='lacG' & stA != stB) %>%
  select(Gene,stA, Gene_Pres_A,stB,Gene_Pres_B)

glyc3 <- merge(glyc3, ps_comp, by.x='stA', by.y='Serotype')
glyc3 <- merge(glyc3, ps_comp, by.x='stB', by.y='Serotype')

View(glyc3)

write.csv(glyc3,'./results/sperm_pairings.csv')

```

